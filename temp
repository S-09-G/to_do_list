"""
Pydantic schemas for API request/response validation.
"""

from pydantic import BaseModel, Field
from typing import List, Dict, Optional, Any
from enum import Enum


# ============================================================
# ENUMS
# ============================================================

class NormalizationMethod(str, Enum):
    none = "none"
    minmax = "minmax"
    standard = "standard"
    tfidf = "tfidf"
    log_tfidf = "log_tfidf"
    row_normalize = "row_normalize"
    balanced = "balanced"


class DimReductionMethod(str, Enum):
    svd = "svd"
    pca = "pca"


class AlgorithmName(str, Enum):
    minibatch_kmeans = "minibatch_kmeans"
    gmm = "gmm"
    birch = "birch"


# ============================================================
# CONFIG SCHEMAS
# ============================================================

class AlgorithmConfig(BaseModel):
    """Configuration for a single algorithm."""
    name: str
    enabled: bool = True
    display_name: Optional[str] = None
    parameters: Dict[str, Any] = {}


class PreprocessingConfig(BaseModel):
    """Preprocessing configuration."""
    normalization: NormalizationMethod = NormalizationMethod.balanced
    dimensionality_reduction: Dict[str, Any] = {
        "enabled": True,
        "method": "svd",
        "n_components": 50
    }


class ClusteringConfig(BaseModel):
    """Clustering configuration."""
    random_state: int = 42
    k_range: Dict[str, int] = {"min": 3, "max": 20}
    algorithms: List[AlgorithmConfig] = []


class ConfigUpdate(BaseModel):
    """Schema for updating configuration."""
    preprocessing: Optional[PreprocessingConfig] = None
    clustering: Optional[ClusteringConfig] = None
    
    class Config:
        extra = "allow"


class ConfigResponse(BaseModel):
    """Full configuration response."""
    paths: Dict[str, str]
    data_sources: Dict[str, Any]
    feature_selection: Dict[str, Any]
    preprocessing: Dict[str, Any]
    clustering: Dict[str, Any]
    evaluation: Dict[str, Any]
    output: Dict[str, Any]
    logging: Dict[str, Any]


# ============================================================
# DATA SCHEMAS
# ============================================================

class DataValidationResponse(BaseModel):
    """Response from data validation."""
    valid: bool
    file_path: str
    n_users: int
    n_features: int
    user_id_column: str
    users_unique: bool
    issues: List[str] = []
    warnings: List[str] = []
    feature_columns: List[str] = []


class DataInfoResponse(BaseModel):
    """Basic data information."""
    file_exists: bool
    file_path: str
    n_rows: Optional[int] = None
    n_columns: Optional[int] = None
    columns: List[str] = []


# ============================================================
# PIPELINE SCHEMAS
# ============================================================

class FeatureEngineeringRequest(BaseModel):
    """Request for feature engineering."""
    normalization: Optional[NormalizationMethod] = None
    use_svd: Optional[bool] = None
    n_components: Optional[int] = None


class FeatureEngineeringResponse(BaseModel):
    """Response from feature engineering."""
    success: bool
    input_shape: Dict[str, int]
    output_shape: Dict[str, int]
    normalization_method: str
    svd_applied: bool
    explained_variance: Optional[float] = None
    output_file: str
    message: str = ""


class CompareAlgorithmsRequest(BaseModel):
    """Request for algorithm comparison."""
    algorithms: Optional[List[AlgorithmName]] = None
    k_min: Optional[int] = None
    k_max: Optional[int] = None


class AlgorithmResult(BaseModel):
    """Result for a single algorithm."""
    algorithm: str
    display_name: str
    best_k: Optional[int] = None
    best_silhouette: Optional[float] = None
    k_values: List[int] = []
    silhouette_scores: List[Optional[float]] = []
    calinski_harabasz_scores: List[Optional[float]] = []
    davies_bouldin_scores: List[Optional[float]] = []


class CompareAlgorithmsResponse(BaseModel):
    """Response from algorithm comparison."""
    success: bool
    results: Dict[str, AlgorithmResult]
    best_overall: Optional[Dict[str, Any]] = None
    report_path: str = ""
    message: str = ""


class TrainModelRequest(BaseModel):
    """Request for training a model."""
    algorithm: AlgorithmName
    n_clusters: int = Field(..., ge=2, le=100)


class ClusterDistribution(BaseModel):
    """Distribution of a single cluster."""
    cluster_id: int
    count: int
    percentage: float


class TrainModelResponse(BaseModel):
    """Response from model training."""
    success: bool
    algorithm: str
    n_clusters: int
    metrics: Dict[str, Optional[float]]
    cluster_distribution: List[ClusterDistribution]
    model_path: str = ""
    assignments_path: str = ""
    message: str = ""


# ============================================================
# GENERAL SCHEMAS
# ============================================================

class ErrorResponse(BaseModel):
    """Standard error response."""
    success: bool = False
    error: str
    detail: Optional[str] = None


class HealthResponse(BaseModel):
    """Health check response."""
    status: str = "healthy"
    version: str = "1.0.0"